#include "MyForm.h"
#include <iostream>
#include <fstream>
#include <ctime>
#include <Time.h>

using namespace System;
using namespace System::Windows::Forms;

using namespace std;

class MyList { // создаём класс
	struct Element { // в котором содержится структура. А в нём содержится двусвязный список
		double number; // каждым членом списка является само число
		Element* next; // и указатели на следующий элемент списка
		Element* prev; // и на прошлый
	};
public:
	Element* first; // создаём указатели-помощники. Указатель на начало списка
	Element* last; // указатель на последний элемент списка
	Element* current; // и на текущий элемент, с которым мы работаем
	int size; // иннициализируем значение размера списка (сколько членов хранится в списке)

	void add_last(double num) { // функция, которая добавляет в КОНЕЦ списка новый элемент
		Element *temp = new Element; // создаём временный элемент структуры, через который мы и будем заносить данные
		if (size != 0) { // если размер текущего списка не равен 0 (в нём есть элементы), то...
			temp->prev = last; // даём указателю данные о последнем элементе списка (приравниваем указатели)
			temp->next = NULL; // указываем, что следующего элемента нету
			temp->number = num; // а в значение элемента записываем полученное число
			last->next = temp; // указываем последнему элементу, что появился новый
			last = temp; // и сдвигаем указатель на последний элемент на новый элемент
		} // т.е. грубо говоря, аналогия - к поезду прицепляем вагон, сцепка - это указатели, а собственно пассажиры - это число
		else { // в случае, если список пустой (== 0), то мы создаём собственно сам список и закладываем первый элемент
			last = temp; // сразу указываем, что новый элемент - это и последний элемент...
			first = temp; // он же и первый (просто потому что он единственный)
			temp->prev = NULL; // указываем, что элемент первый. Прошлого элемента нету, поэтому присваиваем NULL (пустоту)
			temp->next = NULL; // также нету и следующего, поэтому тоже присваиваем NULL
			temp->number = num; // ну и заносим само число
		}
		size++; // а в конце просто делаем к количеству элементов +1. В списке появился ещё 1 элемент
	}

	void add_first(double num) { // функция, которая добавляет в НАЧАЛО списка новый элемент (самым первым)
		Element *temp = new Element; // создаём временный элемент структуры, через который мы и будем заносить данные
		if (size != 0) { // если у нас уже есть элементы в списке...
			temp->prev = NULL; // то пишем, что прошлого элемента нету (мы же в начало добавляем, самым первым. Первее быть не может)
			temp->number = num; // заносим сам элемент (число)
			temp->next = first; // указываем на следующий элемент (он перед этой операцией был первым, поэтому указатель на начало списка)
			first->prev = temp; // указываем бывшему началу списка, что он уже собственно не первый, т.е. на заносимый элемент
			first = temp; // и сдвигаем указатель на начало списка на добавленный элемент
		} // теперь мы вагон прицепляем не к хвосту поезда, в к голове
		else { // если элементов в списке нет, то процедура стандартна :)
			last = temp; // сразу указываем, что новый элемент - это и последний элемент...
			first = temp; // он же и первый (просто потому что он единственный)
			temp->prev = NULL; // указываем, что элемент первый. Прошлого элемента нету, поэтому присваиваем NULL (пустоту)
			temp->next = NULL; // также нету и следующего, поэтому тоже присваиваем NULL
			temp->number = num; // ну и заносим само число
		}
		size++; // ну и стандартный счётчик +1 к количеству элементов в списке
	}


	MyList(int n, int type) { //собственно конструктор класса. Здесь создаём класс. n - размер списка, type - ключ ввода
		if (type == 1) { // получаем значение 1 или 2. Это ключ, который говорит нам, как создаём список. 1 - вводим с клавиатуры
			if (n != 0) { // если введённый размер не равен нулю
				double input; // объявляем значение, через которое будем вводить значения в список
				size = 0; // объявляем, что размер списка 0 и мы начинаем вводить....
				for (int i = 0; i < n; i++) { // и циклом вводим числа через функцию
					cout << "введите число:" << endl;
					cin >> input;
					add_last(input); // отправляем число в функцию, где оно уже и добавится в список
				}
			}
			else { // если мы ввели 0, то...
				Element* temp = new Element; // как и арньше оздаём временный элемент структуры
				temp->number = 0; // заносим туда просто нолик
				temp->next = NULL; // говорим, что следующего элемента нету
				temp->prev = NULL; // как и прошлого (элемент просто один)
				first = temp; // и ставим указатели, что текущий элемент - первый
				last = temp; // и он же последний
				size = 0; // элементов нету, это просто заглушка, поэтому пишем 0
			}
		}
		else { // в противном случае.. число 2 - ввод рандомных чисел (или число 0 (для следующей функции) - создание полностью пустого писка)
			if (n != 0) { // если введённый размер не равен нулю
				size = 0; // объявляем, что размер списка 0 и мы начинаем вводить....
				for (int i = 0; i < n; i++) { // и циклом вводим числа через функцию
					add_last((double)(rand() % 20000 / 431)); // рандомим любые числа от 0 до 20000, причём это число будет потом разделено на 431 (чтобы было вещественное)
				}
			}
			else { // если мы ввели 0, то... по старой схеме (!!!!актуально для следующей функции)
				Element* temp = new Element; // как и арньше оздаём временный элемент структуры
				temp->number = 0; // заносим туда просто нолик
				temp->next = NULL;  // говорим, что следующего элемента нету
				temp->prev = NULL; // как и прошлого (элемент просто один)
				first = temp;  // как и прошлого (элемент просто один)
				last = temp; // и он же последний
				size = 0;// элементов нету, это просто заглушка, поэтому пишем 0
			}
		}
	}

	void matrixReversing() { // функция, которая и собирает необходимый список
		MyList list2(0, 0); // создаём пустой список с 0 элементов (см. функцию выше)
		for (int step = 0; step < size; step++) // через цикл добавляем новые элементы в новый список
			listCreating(list2, step); // принцип вкратце описан ниже
		list2.show(); // и показываем получившийся список!
	}

	void listCreating(MyList &list, int step) { // добавляем в необходимый список по 2 элемента (первый и последний)
		current = first; // приходим в начало списка list1 (!)
		for (int i = 0; i < step; i++) // и делаем step-прыжков с начала списка к необходимому элементу
			current = current->next;
		list.add_last(current->number); // добавляем в КОНЕЦ НОВОГО списка элемент
		current = last;// перескакиваем в конец списка
		for (int i = 0; i < step; i++) // отсчитываем столько же прыжков от конца к началу
			current = current->prev;
		list.add_last(current->number); // и добавляем элемент в КОНЕЦ НОВОГО списка

		// т.е. мы берём, например текущий список 1 2 3 4 5 6
		// если step = 1, то сначала новый список после первого добавления* будет 1
		// после второго уже будет 1 6
		// второй заход в функцию. step = 2
		// после перовго добавления будет выглядеть 1 6 2
		// а после второго - 1 6 2 5
		// и так до конца работы цикла наполнится новый список

		// *под добавлением имеется в виду вызов функции list.add_last(current->number);
	}


	void show() { // функция вывода списка на экран
		current = first; // передвигаем указатель на начало списка
		for (int i = 0; i < size; i++) { // и просто циклом выводим все числа
			cout << current->number << " "; // выводим само число
			current = current->next; // и сдвигаем указатель на следующий элемент
		}
		cout << endl;
	}
};

[STAThreadAttribute]
void Main(array<String^>^ args) {
	Application::EnableVisualStyles(); 
	Application::SetCompatibleTextRenderingDefault(false); 
	LP4::MyForm form; 
	Application::Run(% form);

	setlocale(LC_ALL, "Rus"); // вывод буковок на русском
	srand(time(NULL)); // функция, которая собственно генерирует рандомные числа
	int type, size; // иннициализируем переменные для ввода в меню и для ввода размера списка (количества элементов)
	cout << "Выберите метод ввода" << endl << "с клавиатуры: 1" << endl;
	cout << "случайный подбор: 2" << endl;
	cin >> type;// выбираем меню
	switch (type) { // и через цикл вызываем нужные функции
	case 1: { // ввод с клавиатуры
		cout << endl << "введите размер строки:" << endl;
		cin >> size; // вводим размер будущего списка
		MyList list1(size, 1); // создаём сам список с ключом 1 - это означает, что вводим с клавы
		list1.show(); // показываем его
		list1.matrixReversing(); // переворачиваем
		break; // выходим из цикла
	}
	case 2: {
		cout << endl << "введите размер строки:" << endl;
		cin >> size; // вводим размер будущего списка
		MyList list1(size, 2); // создаём сам список с ключом 2 - все значения в списке будут зарандомлены
		list1.show(); // показываем список
		list1.matrixReversing(); // собственно переворачиваем
		break;// выходим из цикла
	}
	default: cout << "Ошибка ввода!!!" << endl; // если нажали не то, то пишем ошибку и начинаем цикл заново
	}
	system("pause"); // стопим консоль
}
